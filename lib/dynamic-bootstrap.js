// Generate a bootstrap for the UIAuto Instruments script containing
// the environment variables we need.

import path from 'path';
import _ from 'lodash';
import crypto from 'crypto';
import _mkdirp from 'mkdirp';
import _fs from 'fs';
import Promise from 'bluebird';
import buildScript from './resolve-deps';
import log from './logger';

let mkdirp = Promise.promisify(_mkdirp);
let fs = {
  readFile: Promise.promisify(_fs.readFile),
  writeFile: Promise.promisify(_fs.writeFile)
};


function getEnv (opts) {
  opts = opts || {};
  let bootstrapEnv = {
    nodePath: process.execPath,
    commandProxyClientPath: path.resolve(
      __dirname, './bin/command-proxy-client.js'),
    instrumentsSock: opts.sock || '/tmp/instruments_sock',
    interKeyDelay: opts.interKeyDelay || null,
    justLoopInfinitely: opts.justLoopInfinitely,
    autoAcceptAlerts: opts.autoAcceptAlerts,
    autoDismissAlerts: opts.autoDismissAlerts,
    sendKeyStrategy: opts.sendKeyStrategy,
  };
  return bootstrapEnv;
}

async function buildCode (opts) {
  if (opts.code) return opts.code;

  let env = getEnv(opts);
  log.debug(`Dynamic env: ${JSON.stringify(env)}`);

  let bootstrapJs = path.resolve(__dirname, '../../uiauto/bootstrap.js');
  let imports = (opts.imports && opts.imports.pre) ? opts.imports.pre : [];
  let bootstrapCode = await buildScript(bootstrapJs, imports);

  // generate the dynamic part of the bootstrap code
  let lines = [];
  lines.push('// This file is automatically generated. Do not manually modify!');
  lines.push('');
  lines.push(bootstrapCode);
  lines.push('');
  lines.push('bootstrap({');
  for (let [key, value] of _.pairs(env)) {
    if (!_.isUndefined(value)) {
      let quote = _.isString(value) ? '\"' : '';
      lines.push(`  "${key}": ${quote}${value}${quote},`);
    }
  }
  lines[lines.length - 1] = lines[lines.length - 1].replace(/,$/, '');
  lines.push('});');
  return lines.join('\r\n');
}

function computeHash (code) {
  return crypto
    .createHash('md5')
    .update(code)
    .digest('hex')
    .substring(0, 16);
}

function getDynamicBootstrapDir (opts = {}) {
  // figuring out where to store dynamic bootstrap
  let dynamicBootstrapDir;
  if (process.env.APPIUM_BOOTSTRAP_DIR) {
    // mainly for test
    dynamicBootstrapDir = process.env.APPIUM_BOOTSTRAP_DIR;
  } else if (process.env.HOME) {
    dynamicBootstrapDir = path.resolve(process.env.HOME,
      'Library/Application Support/appium/bootstrap');
  } else {
    // no user dir, using tmp
    dynamicBootstrapDir = path.resolve(opts.tmpDir || '/tmp', 'appium/bootstrap');
  }
  return dynamicBootstrapDir;
}

async function writeDynamicBootstrapIfNecessary (dynamicBootstrapDir, dynamicBootstrapPath, code, hash) {
  await mkdirp(dynamicBootstrapDir);
  // check existing code
  let codeIsGood = true;
  try {
    let existingCode = await fs.readFile(dynamicBootstrapPath);
    codeIsGood = computeHash(existingCode) === hash;
  } catch (err) {
    codeIsGood = false;
  }
  // write file if necessary
  if (codeIsGood) {
    log.debug(`Reusing dynamic bootstrap: ${dynamicBootstrapPath}`);
  } else {
    log.debug(`Creating or overwriting dynamic bootstrap: ${dynamicBootstrapPath}`);
    await fs.writeFile(dynamicBootstrapPath, code, {flag: 'w+'});
  }
}

async function prepareBootstrap (opts = {}) {
  log.debug('Preparing bootstrap code');

  let dynamicBootstrapDir = getDynamicBootstrapDir(opts);
  log.debug(`Dynamic bootstrap dir: ${dynamicBootstrapDir}`);

  // building code and hash
  let code = await buildCode(opts);
  let hash = computeHash(code);
  let dynamicBootstrapPath = path.resolve(dynamicBootstrapDir,
    `bootstrap-${hash}.js`);
  log.debug(`Dynamic bootstrap code: ${code.split('\n')[0]}...`);
  log.debug(`Dynamic bootstrap path: ${dynamicBootstrapPath}`);

  await writeDynamicBootstrapIfNecessary(dynamicBootstrapDir,
    dynamicBootstrapPath, code, hash);

  return dynamicBootstrapPath;
}

export { prepareBootstrap, getEnv };
